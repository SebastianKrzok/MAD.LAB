# -*- coding: utf-8 -*-
"""mad1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PWaR6HEN6se8UtoBSU6fIY9I2mbrt85Y
"""

import numpy as np

"""Zad1"""

lista = list(range(1, 11))
print(lista)

"""Zad2"""

arr = np.arange(1, 11, dtype='float32')
print(arr)

"""Zad2"""

arr_1 = np.arange(1, 17)
print(arr_1)

arr_1 = 2 ** arr_1
print(arr_1)

"""Zad4"""

arr_2 = np.arange(1, 26).reshape((5,5))
print(arr_2)

# podajemy parametry dla każdego wymiaru
print(arr_2[-1,-1])
print(arr_2[:,1]) # druga kolumna
print(arr_2[2,:]) # trzeci wiersz
print(arr_2[1:3, 3:5])

"""zadanie 5"""

arr3 = np.arange(27).reshape(3, 3, 3)
widoczne_y1 = arr3[:, 1, :]
widoczne_z1_z3 = arr3[:, :, [0, 2]]


print(widoczne_y1)
print(widoczne_z1_z3)

"""zadanie 6"""

#Bazując na przykładzie z podpunktu 2.3.2 przygotuj test czasu wykonania dla trzech poniższych przypadków:

#inicjalizacja listy 10000 wartości całkowitoliczbowych oraz przemnożenie każdego elementu przez liczbę 2 wykorzystując zapis z pętlą for
#tak jak powyżej, ale z wykorzystaniem list comprehension (dla przypomnienia [wyrażenie for elem in kolekcja])
#dla tablicy numpy

lista2 = list(range(10000))
print(lista2)

for idx in range(len(lista2)):
    lista2[idx] = lista2[idx] * 2

print(lista2)

lista2 = [x * 2 for x in range(10000)]
print(lista2)

tablica = np.arange(10000) * 2
print(tablica)