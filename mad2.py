# -*- coding: utf-8 -*-
"""Mad2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dFmzdAgt6dHQhiw_o2-P6m9mxceR-3ND
"""



"""Stwórz tablicę numpy o wymiarach (4,4) wypełnioną wartościami od 2 do 32 z krokiem 2 i przypisz ją do zmiennej. Wyświetl jej typ danch, liczbę elementów, wielkość pojedynczego elementu oraz ilość zaalokowanej pamięci.

Zadanie 2

Zwróć tablicę z zadania 1 jako widok. Zmień jej typ danych (możesz to zrobić np. funkcją astype()) na np.uint8. Sprawdź teraz czy tablica jest widokiem czy kopią tablicy oryginalnej. Wyświetl jej liczbę elementów, wielkość pojedynczego elementu oraz ilość zaalokowanej pamięci.

Zadanie 3

Wytnij z tablicy z zadania 1 obszar 2 x 2 "ze środka" tablicy (wartości 12,14, 20,22) na dwa sposoby:

jeden jako widok i przypisz do zmiennej
drugi jako kopia i przypisz do zmiennej
Posługując się przykładami z zajęć sprawdź czy baza tych dwóch tablic jest różna (powinna być).

Zadanie 4

Stwórz tablicę 4x4, która zawiera wartości 1,2,3,4 w każdym wierszu. Następnie wykorzystując funkcje łączenia tablic utwórz tablicę połączoną z powyższej tablicy i jej wersji lustrzanej w poziomie (spróbuj użyć wycinków).

Zadanie 5

Utwórz tablicę o nazwie Z_5 o wymiarach 2x2 wypełnioną wartościami 1. Wykorzystując funkcje łączenia tabel uwtórz tablicę, która finalnie będzie tablicą składającą się z 4-ech tablic Z_5, ale tak aby finalnie była to tablica 4 x 4 podobna do poniższej:

1,1,2,2
1,1,2,2
3,3,4,4
3,3,4,4

Zadanie 1
"""

import numpy as np

A = np.arange(2, 34, 2).reshape((4,4))
print(A)

A.nbytes

# wielkość pojedynczego elementu (w bajtach)
A.itemsize

# co daje nam ilość zaalokowanej pamięci dla elementów tablicy
A.itemsize * A.size

# liczba elementów w tablicy
A.size

"""Zadanie 2"""

tab_uint8 = A.astype(np.uint8)
print(tab_uint8)

tab_uint8.dtype

"""Zadanie 3"""

print(A[1:3, 1:3])

def get_data_base(x):
    base = x
    while isinstance(base.base, np.ndarray):
        base = base.base
    return base

def arrays_share_data(x, y):
    return get_data_base(x) is get_data_base(y)

C_widok = A[1:3, 1:3]
C_kopia = A[1:3, 1:3].copy()
print(arrays_share_data(C_widok, A))
print(arrays_share_data(C_kopia, A))

"""zadanie 4"""

D = np.tile(np.arange(1, 5), (4, 1))
D_lustrzane = D[:, ::-1]
D_polaczone = np.hstack((D, D_lustrzane))
print("Tablica połączona:")
print(D_polaczone)

"""zadanie 5"""

Z_5 = np.ones((2, 2), dtype=int)
Z_finalna = np.block([[Z_5, Z_5 + 1], [Z_5 + 2, Z_5 + 3]])
print("Finalna tablica:")
print(Z_finalna)